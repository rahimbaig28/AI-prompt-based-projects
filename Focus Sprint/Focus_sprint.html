<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Focus Sprint</title>
    
    <!-- 
      STYLE SECTION
      All CSS is self-contained within this <style> tag.
      It uses CSS variables for theming and supports a dark mode
      based on user's system preferences.
    -->
    <style>
        /* CSS Variables for theming */
        :root {
            --color-primary: #d95550; /* Pomodoro Red */
            --color-primary-dark: #c04a45;
            --color-short-break: #4a90e2; /* Blue */
            --color-long-break: #4a6de2; /* Darker Blue */
            --color-bg: #f4f7f6;
            --color-surface: #ffffff;
            --color-text: #333333;
            --color-text-secondary: #777777;
            --color-border: #eeeeee;
            --color-success: #4caf50;
            --shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
            --border-radius: 8px;
        }

        /* Dark Mode preferences */
        @media (prefers-color-scheme: dark) {
            :root {
                --color-bg: #121212;
                --color-surface: #1e1e1e;
                --color-text: #eeeeee;
                --color-text-secondary: #aaaaaa;
                --color-border: #333333;
                --shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
            }
        }

        /* Base styles */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            background-color: var(--color-bg);
            color: var(--color-text);
            margin: 0;
            padding: 1rem;
            line-height: 1.6;
            transition: background-color 0.3s, color 0.3s;
        }

        #app {
            max-width: 600px;
            margin: 1rem auto;
            padding: 1.5rem 2rem;
            background-color: var(--color-surface);
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            transition: background-color 0.3s;
        }

        h1, h2 {
            text-align: center;
            margin-top: 0;
        }

        h1 {
            color: var(--color-primary);
            margin-bottom: 1.5rem;
        }

        h2 {
            color: var(--color-text-secondary);
            font-size: 1.25rem;
            border-bottom: 2px solid var(--color-border);
            padding-bottom: 0.5rem;
            margin-bottom: 1.5rem;
        }

        section {
            margin-bottom: 2rem;
        }

        /* --- Timer Section --- */
        .tabs {
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .tabs button {
            padding: 0.6rem 1rem;
            border: none;
            background-color: transparent;
            color: var(--color-text-secondary);
            font-size: 1rem;
            font-weight: 500;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .tabs button.active {
            color: #fff;
        }
        
        /* Dynamic background colors for active tabs */
        body[data-mode="sprint"] .tabs #pomodoro-tab.active { background-color: var(--color-primary); }
        body[data-mode="short"] .tabs #short-tab.active { background-color: var(--color-short-break); }
        body[data-mode="long"] .tabs #long-tab.active { background-color: var(--color-long-break); }


        #timer-display {
            font-size: clamp(4rem, 20vw, 7rem); /* Responsive font size */
            font-weight: bold;
            text-align: center;
            margin: 1rem 0;
            color: var(--color-primary);
            transition: color 0.3s;
        }
        
        /* Dynamic text colors for timer */
        body[data-mode="sprint"] #timer-display { color: var(--color-primary); }
        body[data-mode="short"] #timer-display { color: var(--color-short-break); }
        body[data-mode="long"] #timer-display { color: var(--color-long-break); }

        #session-counter {
            text-align: center;
            font-size: 1.1rem;
            color: var(--color-text-secondary);
            margin-bottom: 1.5rem;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .button {
            padding: 0.75rem 1.25rem;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
            background-color: #ccc;
            color: var(--color-text);
        }

        #start-pause-btn {
            padding: 0.8rem 2.5rem;
            font-size: 1.25rem;
            background-color: var(--color-primary);
            color: #fff;
        }
        
        #start-pause-btn:hover {
             background-color: var(--color-primary-dark);
        }

        body[data-mode="sprint"] #start-pause-btn { background-color: var(--color-primary); }
        body[data-mode="sprint"] #start-pause-btn:hover { background-color: var(--color-primary-dark); }
        body[data-mode="short"] #start-pause-btn { background-color: var(--color-short-break); }
        body[data-mode="long"] #start-pause-btn { background-color: var(--color-long-break); }

        #reset-btn {
            background-color: var(--color-surface);
            border: 2px solid var(--color-border);
        }
        #reset-btn:hover {
            background-color: var(--color-border);
        }

        /* --- Task Section --- */
        #task-form {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        #task-input {
            flex-grow: 1;
            min-width: 200px;
        }
        
        #task-pomos {
            width: 60px;
        }
        
        #add-task-btn {
             background-color: var(--color-short-break);
             color: #fff;
             flex-grow: 1;
             min-width: 100px;
        }
        
        input[type="text"], input[type="number"] {
            padding: 0.6rem;
            border: 1px solid var(--color-border);
            border-radius: 4px;
            background-color: var(--color-bg);
            color: var(--color-text);
            font-size: 1rem;
        }
        
        #task-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }

        #task-list li {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 0.5rem;
            border-bottom: 1px solid var(--color-border);
            word-break: break-word;
        }

        #task-list li:last-child {
            border-bottom: none;
        }

        #task-list input[type="checkbox"] {
            width: 18px;
            height: 18px;
            flex-shrink: 0;
        }

        #task-list .task-text {
            flex-grow: 1;
        }

        #task-list li.completed .task-text {
            text-decoration: line-through;
            color: var(--color-text-secondary);
        }

        #task-list .task-pomos {
            font-size: 0.9rem;
            color: var(--color-text-secondary);
            background-color: var(--color-bg);
            padding: 0.1rem 0.4rem;
            border-radius: 4px;
            flex-shrink: 0;
        }

        #task-list .delete-task-btn {
            background: transparent;
            border: none;
            color: var(--color-text-secondary);
            font-size: 1.25rem;
            cursor: pointer;
            padding: 0.25rem;
            flex-shrink: 0;
        }
        #task-list .delete-task-btn:hover {
            color: var(--color-primary);
        }
        
        #no-tasks-msg {
            text-align: center;
            color: var(--color-text-secondary);
            padding: 1rem;
        }

        /* --- Settings & Stats Section --- */
        .settings-grid {
            display: grid;
            grid-template-columns: 1fr 100px;
            gap: 1rem;
            align-items: center;
            margin-bottom: 1.5rem;
        }
        
        .settings-grid label {
            font-weight: 500;
        }

        .settings-grid input[type="number"] {
            width: 100%;
        }
        
        .settings-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        #session-log {
            list-style: none;
            padding: 0;
            margin: 0 0 1.5rem 0;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid var(--color-border);
            border-radius: 4px;
        }
        
        #session-log li {
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid var(--color-border);
        }
        #session-log li:last-child { border-bottom: none; }
        
        #stats-summary p {
            font-size: 1.1rem;
            margin: 0.5rem 0;
        }
        #stats-summary strong {
            color: var(--color-primary);
        }
        
        .stats-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 1rem;
            margin-top: 1rem;
        }
        
        #stats-period-select {
            padding: 0.5rem;
            border-radius: 4px;
            border: 1px solid var(--color-border);
            background: var(--color-surface);
            color: var(--color-text);
            font-size: 0.9rem;
        }

        #clear-stats-btn {
            background-color: var(--color-primary);
            color: #fff;
            font-size: 0.9rem;
            padding: 0.5rem 1rem;
        }

    </style>
</head>
<body data-mode="sprint">

    <main id="app">
        <!-- 
          TIMER SECTION
          Displays the timer, mode tabs, and controls.
        -->
        <section id="timer-section">
            <h1>Focus Sprint</h1>
            <div class="tabs">
                <button id="pomodoro-tab" class="active" aria-label="Sprint (25 minutes)">Sprint</button>
                <button id="short-tab" aria-label="Short Break (5 minutes)">Short Break</button>
                <button id="long-tab" aria-label="Long Break (15 minutes)">Long Break</button>
            </div>
            
            <div id="timer-display" role="timer" aria-live="assertive">25:00</div>
            
            <div id="session-counter">Session 1</div>

            <div class="controls">
                <button id="start-pause-btn" class="button" aria-label="Start Timer">Start</button>
                <button id="reset-btn" class="button" aria-label="Reset Timer">Reset</button>
            </div>
        </section>

        <!-- 
          TASK SECTION
          Form to add tasks and the list of current tasks.
        -->
        <section id="task-section">
            <h2>Tasks</h2>
            <form id="task-form">
                <input type="text" id="task-input" placeholder="Add a new task..." aria-label="New task description">
                <input type="number" id="task-pomos" value="1" min="1" aria-label="Estimated Sprints">
                <button type="submit" id="add-task-btn" class="button">Add Task</button>
            </form>
            <ul id="task-list">
                <!-- Task items will be dynamically inserted here -->
                <li id="no-tasks-msg">Your tasks will appear here.</li>
            </ul>
        </section>

        <!-- 
          SETTINGS SECTION
          Allows user to customize timer durations, auto-start, and sound.
        -->
        <section id="settings-section">
            <h2>Settings</h2>
            <div class="settings-grid">
                <label for="pomo-duration">Sprint (minutes)</label>
                <input type="number" id="pomo-duration" min="1" value="25">
                
                <label for="short-duration">Short Break (minutes)</label>
                <input type="number" id="short-duration" min="1" value="5">
                
                <label for="long-duration">Long Break (minutes)</label>
                <input type="number" id="long-duration" min="1" value="15">
            </div>

            <div class="settings-toggle">
                <label for="auto-start-toggle">Auto-start next session</label>
                <input type="checkbox" id="auto-start-toggle">
            </div>

            <div class="settings-toggle">
                <span>Sound</span>
                <button id="mute-btn" class="button" aria-label="Mute sound">Mute</button>
            </div>
        </section>
        
        <!-- 
          STATS SECTION
          Displays session log and summary statistics.
        -->
        <section id="stats-section">
            <h2>Statistics</h2>
            
            <ul id="session-log">
                <li>Log will appear here...</li>
            </ul>
            
            <div id="stats-summary">
                <p>No stats yet. Complete a Sprint!</p>
            </div>
            
            <div class="stats-controls">
                <select id="stats-period-select" aria-label="Select statistics period">
                    <option value="today">Today</option>
                    <option value="week">This Week</option>
                    <option value="all">All Time</option>
                </select>
                <button id="clear-stats-btn" class="button">Clear All Stats</button>
            </div>
        </section>
    </main>

    <!-- 
      JAVASCRIPT SECTION
      All application logic is contained within this <script> tag.
    -->
    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- STATE ---
            let state = {
                timer: {
                    intervalId: null,
                    remainingSeconds: 25 * 60, // Default to 25 minutes
                    isRunning: false,
                },
                settings: {
                    sprint: 25,
                    short: 5,
                    long: 15,
                    autoStart: false,
                    muted: false,
                },
                tasks: [],
                stats: {
                    completedSprints: 0,
                    log: [], // { timestamp: Date, event: "Completed Sprint" }
                },
                currentMode: 'sprint', // 'sprint', 'short', 'long'
                sprintCount: 0, // Number of sprints completed in current cycle
            };

            // --- AUDIO CONTEXT (Web Audio API) ---
            let audioCtx;
            let gainNode;
            
            function initAudio() {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    gainNode = audioCtx.createGain();
                    gainNode.connect(audioCtx.destination);
                    gainNode.gain.value = state.settings.muted ? 0 : 0.1; // Start with low volume for tick
                } catch (e) {
                    console.error("Web Audio API is not supported in this browser.", e);
                }
            }

            /**
             * Plays a ticking sound using Web Audio API.
             */
            function playTick() {
                if (!audioCtx || state.settings.muted) return;
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                const oscillator = audioCtx.createOscillator();
                oscillator.type = 'sine'; // A simple beep
                oscillator.frequency.setValueAtTime(600, audioCtx.currentTime); // hertz
                oscillator.connect(gainNode);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.05); // Play for 50ms
            }
            
            /**
             * Plays a sound to signal the end of a session.
             */
            function playFinishSound() {
                if (!audioCtx || state.settings.muted) return;
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                // Stop any ticking
                gainNode.gain.setValueAtTime(0, audioCtx.currentTime);

                const oscillator = audioCtx.createOscillator();
                const finishGain = audioCtx.createGain();
                finishGain.connect(audioCtx.destination);
                finishGain.gain.value = 0.3; // Louder than tick
                
                oscillator.type = 'triangle';
                oscillator.frequency.setValueAtTime(880, audioCtx.currentTime); // A4
                oscillator.connect(finishGain);
                oscillator.start();
                oscillator.stop(audioCtx.currentTime + 0.2);
                
                // Second beep
                const oscillator2 = audioCtx.createOscillator();
                oscillator2.type = 'triangle';
                oscillator2.frequency.setValueAtTime(1046.5, audioCtx.currentTime + 0.3); // C6
                oscillator2.connect(finishGain);
                oscillator2.start(audioCtx.currentTime + 0.3);
                oscillator2.stop(audioCtx.currentTime + 0.5);

                // Reset gain for ticking
                gainNode.gain.setValueAtTime(state.settings.muted ? 0 : 0.1, audioCtx.currentTime + 0.6);
            }

            // --- DOM ELEMENTS ---
            const dom = {
                app: document.getElementById('app'),
                body: document.body,
                
                // Timer
                timerDisplay: document.getElementById('timer-display'),
                startPauseBtn: document.getElementById('start-pause-btn'),
                resetBtn: document.getElementById('reset-btn'),
                sessionCounter: document.getElementById('session-counter'),
                
                // Tabs
                pomoTab: document.getElementById('pomodoro-tab'),
                shortTab: document.getElementById('short-tab'),
                longTab: document.getElementById('long-tab'),
                
                // Tasks
                taskForm: document.getElementById('task-form'),
                taskInput: document.getElementById('task-input'),
                taskPomos: document.getElementById('task-pomos'),
                taskList: document.getElementById('task-list'),
                noTasksMsg: document.getElementById('no-tasks-msg'),

                // Settings
                pomoDurationInput: document.getElementById('pomo-duration'),
                shortDurationInput: document.getElementById('short-duration'),
                longDurationInput: document.getElementById('long-duration'),
                autoStartToggle: document.getElementById('auto-start-toggle'),
                muteBtn: document.getElementById('mute-btn'),

                // Stats
                sessionLog: document.getElementById('session-log'),
                statsSummary: document.getElementById('stats-summary'),
                statsPeriodSelect: document.getElementById('stats-period-select'),
                clearStatsBtn: document.getElementById('clear-stats-btn'),
            };

            // --- LOCAL STORAGE ---
            const STORAGE_KEY = 'focusSprintState';

            /**
             * Saves the current state to localStorage.
             */
            function saveState() {
                try {
                    const stateToSave = {
                        settings: state.settings,
                        tasks: state.tasks,
                        stats: state.stats,
                        sprintCount: state.sprintCount
                    };
                    localStorage.setItem(STORAGE_KEY, JSON.stringify(stateToSave));
                } catch (e) {
                    console.error("Could not save state to localStorage.", e);
                }
            }

            /**
             * Loads state from localStorage.
             */
            function loadState() {
                try {
                    const savedState = localStorage.getItem(STORAGE_KEY);
                    if (savedState) {
                        const parsed = JSON.parse(savedState);
                        // Merge saved state with defaults
                        state.settings = { ...state.settings, ...parsed.settings };
                        state.tasks = parsed.tasks || [];
                        state.stats = parsed.stats || { completedSprints: 0, log: [] };
                        state.sprintCount = parsed.sprintCount || 0;
                    }
                } catch (e) {
                    console.error("Could not load state from localStorage.", e);
                }
                
                // Apply loaded settings to UI
                dom.pomoDurationInput.value = state.settings.sprint;
                dom.shortDurationInput.value = state.settings.short;
                dom.longDurationInput.value = state.settings.long;
                dom.autoStartToggle.checked = state.settings.autoStart;
                dom.muteBtn.textContent = state.settings.muted ? 'Unmute' : 'Mute';
                
                // Set initial timer
                updateTimerDisplay(state.settings.sprint * 60);
                state.timer.remainingSeconds = state.settings.sprint * 60;

                // Render components
                renderTasks();
                renderLog();
                renderStats();
                updateSessionCounter();
            }

            // --- NOTIFICATIONS ---
            /**
             * Requests permission for desktop notifications.
             */
            function requestNotificationPermission() {
                if (!('Notification' in window)) {
                    console.log("This browser does not support desktop notification");
                } else if (Notification.permission !== 'denied') {
                    Notification.requestPermission();
                }
            }

            /**
             * Sends a desktop notification.
             * @param {string} title - The notification title.
             * @param {string} body - The notification body.
             */
            function sendNotification(title, body) {
                if (Notification.permission === 'granted') {
                    new Notification(title, { body: body });
                }
            }

            // --- TIMER LOGIC ---
            
            /**
             * Starts or pauses the timer.
             */
            function toggleTimer() {
                // Resume audio context if suspended (required by some browsers)
                if (audioCtx && audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }
                
                if (state.timer.isRunning) {
                    pauseTimer();
                } else {
                    startTimer();
                }
            }

            /**
             * Starts the timer interval.
             */
            function startTimer() {
                state.timer.isRunning = true;
                dom.startPauseBtn.textContent = 'Pause';
                dom.startPauseBtn.setAttribute('aria-label', 'Pause Timer');

                state.timer.intervalId = setInterval(() => {
                    state.timer.remainingSeconds--;
                    updateTimerDisplay(state.timer.remainingSeconds);
                    playTick();

                    if (state.timer.remainingSeconds <= 0) {
                        sessionComplete();
                    }
                }, 1000);
            }

            /**
             * Pauses the timer interval.
             */
            function pauseTimer() {
                state.timer.isRunning = false;
                dom.startPauseBtn.textContent = 'Start';
                dom.startPauseBtn.setAttribute('aria-label', 'Start Timer');
                clearInterval(state.timer.intervalId);
                state.timer.intervalId = null;
            }
            
            /**
             * Resets the timer to the current mode's duration.
             */
            function resetTimer() {
                pauseTimer();
                let newDuration;
                switch (state.currentMode) {
                    case 'short':
                        newDuration = state.settings.short * 60;
                        break;
                    case 'long':
                        newDuration = state.settings.long * 60;
                        break;
                    case 'sprint':
                    default:
                        newDuration = state.settings.sprint * 60;
                        break;
                }
                state.timer.remainingSeconds = newDuration;
                updateTimerDisplay(newDuration);
            }

            /**
             * Updates the timer display (MM:SS) and document title.
             * @param {number} totalSeconds - The total remaining seconds.
             */
            function updateTimerDisplay(totalSeconds) {
                const minutes = Math.floor(totalSeconds / 60);
                const seconds = totalSeconds % 60;
                const display = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                dom.timerDisplay.textContent = display;
                document.title = `${display} - Focus Sprint`;
            }

            /**
             * Handles the completion of a timer session.
             */
            function sessionComplete() {
                pauseTimer();
                playFinishSound();

                let notificationTitle = 'Time\'s up!';
                let nextMode = 'sprint';
                
                if (state.currentMode === 'sprint') {
                    state.sprintCount++;
                    state.stats.completedSprints++;
                    logEvent(`Completed Sprint #${state.sprintCount}`);
                    
                    if (state.sprintCount % 4 === 0) {
                        notificationTitle = 'Sprint complete! Time for a long break.';
                        nextMode = 'long';
                    } else {
                        notificationTitle = 'Sprint complete! Time for a short break.';
                        nextMode = 'short';
                    }
                } else {
                    logEvent(`Completed ${state.currentMode === 'short' ? 'Short' : 'Long'} Break`);
                    notificationTitle = 'Break\'s over! Time to focus.';
                    nextMode = 'sprint';
                }
                
                sendNotification(notificationTitle, 'Click here to start the next session.');
                switchMode(nextMode);
                
                if (state.settings.autoStart) {
                    startTimer();
                }
                
                // Update stats and save
                renderLog();
                renderStats();
                updateSessionCounter();
                saveState();
            }
            
            /**
             * Switches the timer mode.
             * @param {'sprint' | 'short' | 'long'} mode - The mode to switch to.
             */
            function switchMode(mode) {
                if (state.timer.isRunning) {
                   if (!confirm("A timer is running. Are you sure you want to switch? This will reset the current timer.")) {
                       return;
                   }
                }
                
                state.currentMode = mode;
                dom.body.dataset.mode = mode;

                // Update tab active states
                dom.pomoTab.classList.toggle('active', mode === 'sprint');
                dom.shortTab.classList.toggle('active', mode === 'short');
                dom.longTab.classList.toggle('active', mode === 'long');
                
                resetTimer();
                updateSessionCounter();
            }
            
            function updateSessionCounter() {
                if(state.currentMode === 'sprint') {
                    dom.sessionCounter.textContent = `Session ${state.sprintCount + 1}`;
                } else {
                    dom.sessionCounter.textContent = `On a ${state.currentMode === 'short' ? 'Short' : 'Long'} Break`;
                }
            }

            // --- TASK MANAGEMENT ---

            /**
             * Renders the task list from the state.
             */
            function renderTasks() {
                dom.taskList.innerHTML = ''; // Clear list
                if (state.tasks.length === 0) {
                    dom.taskList.appendChild(dom.noTasksMsg);
                    return;
                }
                
                state.tasks.forEach(task => {
                    const li = document.createElement('li');
                    li.dataset.id = task.id;
                    li.className = task.completed ? 'completed' : '';
                    
                    li.innerHTML = `
                        <input type="checkbox" class="task-checkbox" ${task.completed ? 'checked' : ''} aria-label="Toggle task completion">
                        <span class="task-text">${escapeHTML(task.text)}</span>
                        <span class="task-pomos">${task.pomos} sprint${task.pomos > 1 ? 's' : ''}</span>
                        <button class="delete-task-btn" aria-label="Delete task">&times;</button>
                    `;
                    dom.taskList.appendChild(li);
                });
            }

            /**
             * Handles the task form submission.
             * @param {Event} e - The form submit event.
             */
            function handleAddTask(e) {
                e.preventDefault();
                const text = dom.taskInput.value.trim();
                const pomos = parseInt(dom.taskPomos.value, 10);
                
                if (text === '' || isNaN(pomos) || pomos < 1) {
                    return; // Basic validation
                }
                
                const newTask = {
                    id: Date.now().toString(),
                    text: text,
                    pomos: pomos,
                    completed: false,
                };
                
                state.tasks.push(newTask);
                
                // Clear form
                dom.taskInput.value = '';
                dom.taskPomos.value = '1';
                
                renderTasks();
                saveState();
            }

            /**
             * Handles clicks within the task list (for complete/delete).
             * @param {Event} e - The click event.
             */
            function handleTaskListClick(e) {
                const target = e.target;
                const li = target.closest('li');
                if (!li || !li.dataset.id) return;
                
                const taskId = li.dataset.id;

                if (target.classList.contains('task-checkbox')) {
                    toggleTask(taskId);
                } else if (target.classList.contains('delete-task-btn')) {
                    deleteTask(taskId);
                }
            }

            /**
             * Toggles the completion state of a task.
             * @param {string} id - The ID of the task to toggle.
             */
            function toggleTask(id) {
                const task = state.tasks.find(t => t.id === id);
                if (task) {
                    task.completed = !task.completed;
                    renderTasks();
                    saveState();
                }
            }

            /**
             * Deletes a task from the state.
             * @param {string} id - The ID of the task to delete.
             */
            function deleteTask(id) {
                state.tasks = state.tasks.filter(t => t.id !== id);
                renderTasks();
                saveState();
            }

            // --- SETTINGS MANAGEMENT ---
            
            /**
             * Saves all settings from the UI to the state and localStorage.
             */
            function saveSettings() {
                state.settings.sprint = parseInt(dom.pomoDurationInput.value, 10) || 25;
                state.settings.short = parseInt(dom.shortDurationInput.value, 10) || 5;
                state.settings.long = parseInt(dom.longDurationInput.value, 10) || 15;
                state.settings.autoStart = dom.autoStartToggle.checked;
                
                saveState();
                
                // If not running, update timer to reflect new settings
                if (!state.timer.isRunning) {
                    resetTimer();
                }
            }
            
            /**
             * Toggles the mute state for all sounds.
             */
            function toggleMute() {
                state.settings.muted = !state.settings.muted;
                dom.muteBtn.textContent = state.settings.muted ? 'Unmute' : 'Mute';
                
                if (gainNode) {
                    gainNode.gain.setValueAtTime(state.settings.muted ? 0 : 0.1, audioCtx.currentTime);
                }
                
                saveState();
            }

            // --- STATS & LOGGING ---
            
            /**
             * Adds an event to the session log.
             * @param {string} eventText - The text to log.
             */
            function logEvent(eventText) {
                const logEntry = {
                    timestamp: new Date().toISOString(),
                    event: eventText,
                };
                state.stats.log.unshift(logEntry); // Add to beginning
                
                // Keep log from growing too large
                if (state.stats.log.length > 100) {
                    state.stats.log.pop();
                }
            }
            
            /**
             * Renders the session log in the UI.
             */
            function renderLog() {
                dom.sessionLog.innerHTML = ''; // Clear log
                if (state.stats.log.length === 0) {
                    dom.sessionLog.innerHTML = '<li>Log will appear here...</li>';
                    return;
                }
                
                state.stats.log.forEach(entry => {
                    const li = document.createElement('li');
                    const time = new Date(entry.timestamp).toLocaleTimeString();
                    li.textContent = `[${time}] ${escapeHTML(entry.event)}`;
                    dom.sessionLog.appendChild(li);
                });
            }

            /**
             * Renders the statistics summary based on the selected period.
             */
            function renderStats() {
                const period = dom.statsPeriodSelect.value;
                const { pomos, time } = getStatsForPeriod(period);
                
                if (pomos === 0) {
                     dom.statsSummary.innerHTML = '<p>No stats yet. Complete a Sprint!</p>';
                     return;
                }
                
                const timeHours = (time / 60).toFixed(1);

                dom.statsSummary.innerHTML = `
                    <p><strong>${pomos}</strong> Sprint${pomos !== 1 ? 's' : ''} completed</p>
                    <p><strong>${timeHours}</strong> hours of focus time</p>
                `;
            }
            
            /**
             * Calculates stats for a given period.
             * @param {'today' | 'week' | 'all'} period - The period to calculate for.
             * @returns {{pomos: number, time: number}} - The stats object.
             */
            function getStatsForPeriod(period) {
                let pomos = 0;
                let time = 0;
                const pomoDuration = state.settings.sprint; // Use current setting as approximation

                const today = getDayString(new Date());
                const thisWeek = getWeekString(new Date());

                if (period === 'all') {
                    pomos = state.stats.completedSprints;
                    time = state.stats.completedSprints * pomoDuration;
                } else {
                    // Filter log for relevant entries
                    const relevantLogs = state.stats.log.filter(entry => {
                        if (!entry.event.includes('Completed Sprint')) return false;
                        
                        const entryDate = new Date(entry.timestamp);
                        if (period === 'today') {
                            return getDayString(entryDate) === today;
                        } else if (period === 'week') {
                            return getWeekString(entryDate) === thisWeek;
                        }
                        return false;
                    });
                    
                    pomos = relevantLogs.length;
                    time = pomos * pomoDuration;
                }
                
                return { pomos, time };
            }
            
            /**
             * Clears all statistics and logs.
             */
            function clearStats() {
                if (confirm("Are you sure you want to clear all stats and logs? This cannot be undone.")) {
                    state.stats = { completedSprints: 0, log: [] };
                    state.sprintCount = 0;
                    saveState();
                    renderLog();
                    renderStats();
                    updateSessionCounter();
                }
            }

            // --- UTILITY FUNCTIONS ---
            
            /**
             * Gets a YYYY-MM-DD string from a Date object.
             * @param {Date} date - The date object.
             */
            function getDayString(date) {
                return date.toISOString().split('T')[0];
            }

            /**
             * Gets a YYYY-WW string from a Date object.
             * @param {Date} date - The date object.
             */
            function getWeekString(date) {
                const d = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()));
                d.setUTCDate(d.getUTCDate() + 4 - (d.getUTCDay() || 7)); // Set to Thursday of current week
                const yearStart = new Date(Date.UTC(d.getUTCFullYear(), 0, 1));
                const weekNo = Math.ceil((((d - yearStart) / 86400000) + 1) / 7);
                return `${d.getUTCFullYear()}-${String(weekNo).padStart(2, '0')}`;
            }

            /**
             * Escapes HTML to prevent XSS.
             * @param {string} str - The string to escape.
             */
            function escapeHTML(str) {
                return str.replace(/[&<>"']/g, (match) => {
                    return {
                        '&': '&amp;',
                        '<': '&lt;',
                        '>': '&gt;',
                        '"': '&quot;',
                        "'": '&#39;'
                    }[match];
                });
            }

            // --- EVENT LISTENERS ---
            
            // Timer Controls
            dom.startPauseBtn.addEventListener('click', toggleTimer);
            dom.resetBtn.addEventListener('click', resetTimer);

            // Mode Tabs
            dom.pomoTab.addEventListener('click', () => switchMode('sprint'));
            dom.shortTab.addEventListener('click', () => switchMode('short'));
            dom.longTab.addEventListener('click', () => switchMode('long'));

            // Task Form
            dom.taskForm.addEventListener('submit', handleAddTask);
            dom.taskList.addEventListener('click', handleTaskListClick);

            // Settings
            dom.pomoDurationInput.addEventListener('change', saveSettings);
            dom.shortDurationInput.addEventListener('change', saveSettings);
            dom.longDurationInput.addEventListener('change', saveSettings);
            dom.autoStartToggle.addEventListener('change', saveSettings);
            dom.muteBtn.addEventListener('click', toggleMute);
            
            // Stats
            dom.statsPeriodSelect.addEventListener('change', renderStats);
            dom.clearStatsBtn.addEventListener('click', clearStats);
            
            // Keyboard Controls
            window.addEventListener('keydown', (e) => {
                // Don't interfere when user is typing in inputs
                if (e.target.matches('input') || e.target.matches('textarea')) {
                    return;
                }
                
                switch(e.key) {
                    case ' ': // Spacebar
                        e.preventDefault();
                        toggleTimer();
                        break;
                    case 'r':
                    case 'R':
                        resetTimer();
                        break;
                    case '1':
                        switchMode('sprint');
                        break;
                    case '2':
                        switchMode('short');
                        break;
                    case '3':
                        switchMode('long');
                        break;
                    case 'a':
                    case 'A':
                        e.preventDefault();
                        dom.taskInput.focus();
                        break;
                    case 'm':
                    case 'M':
                        toggleMute();
                        break;
                }
            });
            
            // --- INITIALIZATION ---
            initAudio();
            loadState();
            requestNotificationPermission();
        });
    </script>
</body>
</html>

